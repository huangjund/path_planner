#ifndef _HYBRID_A_STAR_CC_SERVER_H_
#define _HYBRID_A_STAR_CC_SERVER_H_

#include <unistd.h>

#include <VnUtils/core/logger.hh>
#include <VnUtils/core/cyclic_thread.hh>
#include <VnUtils/core/xml_configurable.hh>
#include <VnUtils/geometry/position_2d.hh>
#include <VnUtils/communication/agv.hh>
#include <VnUtils/communication/agv_manager.hh>
#include <VnUtils/communication/task_list_parser.hh>

#include <jsonrpccxx/cpphttplibconnector.hpp>
#include <jsonrpccxx/client.hpp>

#include <opencv2/highgui.hpp>

#include <ros/ros.h>
#include <std_msgs/String.h>
#include <gazebo_msgs/GetModelState.h>

using namespace vn::communication;
using namespace vn::core;
using namespace vn::geometry;
using namespace jsonrpccxx;
using namespace std;
using namespace cv;
using namespace tinyxml2;

/**
 * @brief structure from json rpc
 * 
 */
struct StorageBin
{
	int id;
	float x;
	float y;
	float z;
	float theta;
	bool flip;
};

/**
 * @brief structure from json rpc
 * 
 */
struct ObstaclePose {
	double hrzDis;	// horizontal distance
	double vtcDis;	// vertical distance
};

// for storage bin
void to_json(nlohmann::json& j, const StorageBin& p) { 
	j = nlohmann::json{ 
		{"id", p.id}, 
		{"x", p.x}, 
		{"y", p.y}, 
		{"z", p.z},
		{"theta", p.theta},
		{"flip", p.flip}
	};
}
void from_json(const nlohmann::json& j, StorageBin& p) {
	j.at("id").get_to(p.id);
	j.at("x").get_to(p.x);
	j.at("y").get_to(p.y);
	j.at("z").get_to(p.z);
	j.at("theta").get_to(p.theta);
	j.at("flip").get_to(p.flip);
}

// for obstacle position
void to_json(nlohmann::json& j, const ObstaclePose& p) { 
	j = nlohmann::json{ 
		{"horizontal_distance_", p.hrzDis}, 
		{"vertical_distance_", p.vtcDis}
	};
}
void from_json(const nlohmann::json& j, ObstaclePose& p) {
	j.at("horizontal_distance_").get_to(p.hrzDis);
	j.at("vertical_distance_").get_to(p.vtcDis);
}


/**
 * @brief control center configuration
 * 
 */
class CCConfig : public vn::core::XmlConfigurable
{
 public:
	CCConfig(): 
    port_(9101),
    truck_detection_ip_("192.168.1.246"),
    truck_detection_port_(8484){}

	int getServerPort()
	{
		return port_;
	}
	std::string getTruckDetectionIp()
	{
		return truck_detection_ip_;
	}
	int getTruckDetectionPort()
	{
		return truck_detection_port_;
	}
 protected:

	/**
	 * @brief       Implementation of loading of the configurations.
	 * @param[in]   element XML element to read from.
	 * @return success or not
	 */
	virtual bool loadConfigImpl(tinyxml2::XMLElement* element) override;

 private:
	int port_;
	std::string truck_detection_ip_;
	int truck_detection_port_;
};


/**
 * @brief AGV manager
 * 
 */
class PlannerAgvManager : public AgvManager
{
 public:
	PlannerAgvManager(int port, int timeout = 10) : 
		AgvManager(port,timeout) {}

	void addTaskGroup(std::list<AgvTask> tasks){
		lock_guard<mutex> locker(tasks_mutex_);
		tasks_ = tasks;
	}

	/**
	 * @brief check \p tasks_ , and assgin it to agvs
	 * 
	 */
	void checkAndAssign();

	std::list<AgvTask> getTaskGroups()
	{
		return tasks_;
	}
 private:
	virtual void onTaskCompletedOrCancelled(
      const std::string agv_id, 
      int64 task_id, 
      const std::map<std::string, std::string>& info);

 protected:
	virtual void onTaskCompleted(const std::string agv_id, int64 task_id, const std::map<std::string, std::string>& info)
	{
		onTaskCompletedOrCancelled(agv_id, task_id, info);
	}

	virtual void onTaskCancelled(const std::string agv_id, int64 task_id, const std::map<std::string, std::string>& info)
	{
		onTaskCompletedOrCancelled(agv_id, task_id, info);
	}
 protected:
	std::mutex tasks_mutex_;
	std::list<AgvTask> tasks_;
};

/**
 * @brief control center, which communicate with planner based on ros, 
 * 				communicate with sensor based on json rpc and communicate with agv based on tcp/ip
 * 
 */
class PlannerCC
{
 public:
	PlannerCC(int port, std::string sensor_ip, int sensor_port);

	~PlannerCC() {
		refresh_thread_.stop();
		main_thread_.stop();
	}

 private:
 /**
  * @brief main thread loop this function. check and assgin tasks
  * 
  */
	void main();

	/**
	 * @brief path, generated by planner, to AGV manager. Triggered when a path is sent through ros topic from planner.
	 * 				The path is captured by \p sub_path_
	 * 
	 * @param msg path message sent from planner through ros topic
	 */
	void generateTaskLists(const std_msgs::String::ConstPtr& msg);

	/**
	 * @brief Get the Agv Pos. Triggered by \p pos_server_ .
	 * 
	 * @param req request from planner
	 * @param res response to planner
	 * @return true 
	 * @return false 
	 */
	bool getAgvPos(gazebo_msgs::GetModelState::Request& req,
								 gazebo_msgs::GetModelState::Response& res);

	/**
	 * @brief not in use
	 * 
	 */
	void tryStartMonitor();

	/**
	 * @brief try get goal pose from Sensor
	 * 
	 */
	void refreshSensorDetection();


	void closeSensorDetection();

 private:
	PlannerAgvManager agv_manager_;

	static int64 task_id_;

	CyclicThread main_thread_;
	bool ready_;

	CyclicThread refresh_thread_;			/*!< thread that monitors the detection of the truck */
	bool sensor_started_;			/*!< whether the sensor module is started */
	bool start_loading_;					/*!< try start load the sensor, if the sensor is not found, will be set to false */
	bool start_obs_ = false;			// try start load the obstacles
	static int rpc_id_;						/*!< rpc call id */
	CppHttpLibClientConnector httpClient_;	/*!< http client of sensor */
	JsonRpcClient client_;					/*!< json rpc client of sensor */

	StorageBin goalPos_;
	std::mutex mutexGoalPos_;
	std::condition_variable condition_;
	bool goalReady_;

	// for ros communication
	ros::NodeHandle node_;
	ros::Subscriber sub_path_;
	ros::ServiceServer pos_server_;
	ros::Publisher pub_Obs_;
};
int PlannerCC::rpc_id_ = 0;	// rpc id counts for the callings to the sensor?
int64 PlannerCC::task_id_ = 1;

#endif